#pragma kernel CSMain

// =============================================================================
// GPU Ray Tracing Compute Shader with BVH Acceleration
// 
// Architecture:
// - Rays are generated in Camera Space and transformed to Object Space
// - BVH traversal uses a manual stack for GPU efficiency
// - Supports reflection, refraction, and shadow rays
// - Shading uses Blinn-Phong with configurable lighting components
// =============================================================================

// ===== Data Structures =====

struct Ray
{
    float3 origin;
    float3 direction;
    float3 invDirection;  // Pre-computed for fast AABB intersection
};

struct HitRecord
{
    bool hit;              // True if ray hit geometry
    float t;               // Distance to hit point
    float3 position;       // World-space hit position
    float3 normal;         // Interpolated surface normal
    int materialIndex;     // Index into Materials buffer
};

struct GPUBVHNode
{
    float3 min;            // AABB minimum corner
    int leftOrFirst;       // Internal: left child index | Leaf: first triangle index
    float3 max;            // AABB maximum corner
    int count;             // Internal: 0 | Leaf: triangle count
};

struct GPUTriangle
{
    float3 v0;             // Vertex 0 position
    float3 v1;             // Vertex 1 position
    float3 v2;             // Vertex 2 position
    float3 n0;             // Vertex 0 normal (for smooth shading)
    float3 n1;             // Vertex 1 normal
    float3 n2;             // Vertex 2 normal
    float3 center;         // Pre-computed centroid
    int materialIndex;     // Material reference
};

struct GPUMaterial
{
    float3 color;          // Base surface color
    float ambient;         // Ambient coefficient
    float diffuse;         // Diffuse coefficient (Lambertian)
    float specular;        // Specular coefficient (mirror reflection)
    float refraction;      // Refraction coefficient (transparency)
    float ior;             // Index of refraction
};

// ===== Shader Resources =====

RWTexture2D<float4> Result;              // Output render target
StructuredBuffer<GPUBVHNode> BVHNodes;   // Flattened BVH tree
StructuredBuffer<GPUTriangle> Triangles;  // Scene triangles
StructuredBuffer<GPUMaterial> Materials;  // Material definitions

// ===== Shader Uniforms =====

float4x4 _CameraToWorld;         // Transforms rays from Camera Space to Object Space
float4x4 _CameraInverseProjection;
float _CameraDistance;           // Distance from camera to projection plane
float _CameraFOV;                // Vertical field of view in degrees
float3 _LightDirection;          // (Unused - using _LightPosition instead)
float _Time;                     // Animation time
int _MaxDepth;                   // Maximum ray recursion depth
int _DebugMode;                  // 0=normal, 1=depth, 2=normals, 3=hit visualization
int _EnableAmbient;              // Toggle ambient lighting
int _EnableDiffuse;              // Toggle diffuse lighting
int _EnableSpecular;             // Toggle specular highlights
int _EnableRefraction;           // Toggle refraction/transparency
float _LightIntensity;           // Global light intensity multiplier
float3 _LightPosition;           // Point light position in Object Space
float4 _BackgroundColor;         // Color for rays that miss all geometry
int _IsOrthographic;             // 0=perspective, 1=orthographic
int _AASamples;              // Number of AA samples per pixel (1, 2, 4, 8, etc.)
float _OrthoSize;                // Orthographic viewport half-height

// ===== Constants =====

static const float Infinity = 3.402823466e+38;
static const float Epsilon = 1e-4;

// =============================================================================
// Random Number Generator (Hash)
// =============================================================================

float2 Hash22(float2 p)
{
    float3 p3 = frac(float3(p.xyx) * float3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yzx + 33.33);
    return frac((p3.xx+p3.yz)*p3.zy);
}

// =============================================================================
// Ray Creation
// =============================================================================

Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    ray.invDirection = 1.0f / direction;  // Pre-compute for AABB slab test
    return ray;
}

// =============================================================================
// Triangle Intersection (MÃ¶ller-Trumbore Algorithm)
// 
// Fast ray-triangle intersection with barycentric coordinate output.
// Updates bestHit only if this intersection is closer than the current best.
// =============================================================================

void IntersectTriangle(Ray ray, GPUTriangle tri, inout HitRecord bestHit)
{
    float3 v0v1 = tri.v1 - tri.v0;
    float3 v0v2 = tri.v2 - tri.v0;
    float3 pvec = cross(ray.direction, v0v2);
    float det = dot(v0v1, pvec);

    // Skip nearly parallel rays (includes backfaces if det < 0)
    if (abs(det) < Epsilon) return;

    float invDet = 1.0f / det;
    float3 tvec = ray.origin - tri.v0;
    float u = dot(tvec, pvec) * invDet;

    // Check u barycentric coordinate bounds
    if (u < 0.0f || u > 1.0f) return;

    float3 qvec = cross(tvec, v0v1);
    float v = dot(ray.direction, qvec) * invDet;

    // Check v barycentric coordinate bounds
    if (v < 0.0f || u + v > 1.0f) return;

    float t = dot(v0v2, qvec) * invDet;

    // Check if this is the closest hit so far
    if (t > Epsilon && t < bestHit.t)
    {
        bestHit.hit = true;
        bestHit.t = t;
        bestHit.position = ray.origin + t * ray.direction;
        
        // Interpolate vertex normals using barycentric coordinates (smooth shading)
        float w = 1.0 - u - v;
        bestHit.normal = normalize(w * tri.n0 + u * tri.n1 + v * tri.n2);
        bestHit.materialIndex = tri.materialIndex;
    }
}

// =============================================================================
// AABB Intersection (Slab Method)
// 
// Fast ray-box intersection using the slab method.
// Returns distance to entry point, or Infinity if no intersection.
// =============================================================================

float IntersectAABB(Ray ray, float3 boxMin, float3 boxMax)
{
    float3 t0 = (boxMin - ray.origin) * ray.invDirection;
    float3 t1 = (boxMax - ray.origin) * ray.invDirection;
    
    // Handle negative ray directions
    float3 tmin = min(t0, t1);
    float3 tmax = max(t0, t1);
    
    // Find intersection of all slabs
    float dstA = max(max(tmin.x, tmin.y), tmin.z);  // Entry point
    float dstB = min(min(tmax.x, tmax.y), tmax.z);  // Exit point
    
    // No intersection if entry is after exit or exit is behind ray origin
    if (dstA > dstB || dstB < 0) return Infinity;
    
    return dstA;
}

// =============================================================================
// BVH Traversal
// 
// Iterative traversal using a manual stack for GPU efficiency.
// Tests ray against all triangles in leaf nodes, using AABB culling for branches.
// =============================================================================

HitRecord TraverseBVH(Ray ray)
{
    HitRecord hit;
    hit.hit = false;
    hit.t = Infinity;
    hit.normal = float3(0, 1, 0);
    hit.position = float3(0, 0, 0);
    hit.materialIndex = -1;

    // Manual stack (avoid recursion on GPU)
    int stack[32];
    int stackPtr = 0;
    stack[stackPtr++] = 0;  // Push root node

    while (stackPtr > 0)
    {
        int nodeIdx = stack[--stackPtr];
        GPUBVHNode node = BVHNodes[nodeIdx];

        // Early exit: skip if AABB is farther than current best hit
        float dst = IntersectAABB(ray, node.min, node.max);
        if (dst >= hit.t) continue;

        if (node.count > 0)  // Leaf node
        {
            // Test all triangles in this leaf
            for (int i = 0; i < node.count; i++)
            {
                GPUTriangle tri = Triangles[node.leftOrFirst + i];
                IntersectTriangle(ray, tri, hit);
            }
        }
        else  // Internal node
        {
            // Push children (right first so left is processed first)
            int leftIdx = node.leftOrFirst;
            stack[stackPtr++] = leftIdx + 1;  // Right child
            stack[stackPtr++] = leftIdx;       // Left child
        }
    }
    
    return hit;
}

// =============================================================================
// Shading (Simplified version for non-recursive use)
// =============================================================================

float3 Shade(Ray ray, HitRecord hit)
{
    if (!hit.hit) return float3(0.05, 0.05, 0.05);

    // Get material properties
    float3 matColor = float3(1, 1, 1);
    float kAmbient = 0.1;
    float kDiffuse = 0.7;
    float kSpecular = 0.0;
    
    if (hit.materialIndex >= 0)
    {
        GPUMaterial mat = Materials[hit.materialIndex];
        matColor = mat.color;
        kAmbient = mat.ambient;
        kDiffuse = mat.diffuse;
        kSpecular = mat.specular;
    }

    float3 result = float3(0, 0, 0);
    
    // Ambient component
    if (_EnableAmbient == 1)
    {
        result += matColor * kAmbient;
    }
    
    // Diffuse and specular from directional light
    if (_EnableDiffuse == 1 || _EnableSpecular == 1)
    {
        float3 lightDir = normalize(float3(1, 1, -1));
        float NdotL = max(0.0f, dot(hit.normal, lightDir));
        
        if (_EnableDiffuse == 1)
        {
            result += matColor * kDiffuse * NdotL;
        }
        
        if (_EnableSpecular == 1 && kSpecular > 0.0)
        {
            // Blinn-Phong specular
            float3 viewDir = normalize(-ray.direction);
            float3 halfVec = normalize(lightDir + viewDir);
            float spec = pow(max(dot(hit.normal, halfVec), 0.0), 32.0);
            result += float3(1,1,1) * kSpecular * spec;
        }
    }
    
    return result * _LightIntensity;
}


// =============================================================================
// Main Kernel
// =============================================================================

[numthreads(8, 8, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);
    
    // Bounds check
    if (id.x >= width || id.y >= height) return;

    // ==========================================================================
    // RAY GENERATION & JITTERED SAMPLING
    // 
    // If AA is enabled (>1 sample), we divide the pixel into a grid and
    // jitter the ray position within each cell to reduce aliasing.
    // ==========================================================================
    
    // Ensure at least 1 sample
    int sampleCount = max(1, _AASamples);
    
    // Calculate grid dimensions for stratification
    // e.g. 4 samples -> 2x2 grid. 8 samples -> 3x3 grid (approx)
    // For non-square numbers we just do a best-fit or full random if complex,
    // but here we use a dynamic grid approach.
    float gridSize = sqrt((float)sampleCount);
    int gridW = ceil(gridSize);
    int gridH = ceil((float)sampleCount / (float)gridW);
    
    float3 pixelColorAccum = float3(0, 0, 0);
    
    // Calculate projection plane dimensions based on FOV
    float aspect = (float)width / (float)height;
    float halfHeight = _CameraDistance * tan(radians(_CameraFOV) * 0.5);
    float planeHeight = 2.0 * halfHeight;
    float planeWidth = planeHeight * aspect;

    for (int i = 0; i < sampleCount; i++)
    {
        // 1. Calculate Sub-Pixel Position (Jittered)
        // ------------------------------------------
        float2 offset = float2(0.5, 0.5); // Default center
        
        if (sampleCount > 1)
        {
            // Stratified Sampling: determine grid cell (gx, gy)
            int gy = i / gridW;
            int gx = i % gridW;
            
            // Random jitter within the cell [0, 1]
            float2 jitter = Hash22(float2(id.x + i * 13.0, id.y + i * 7.0));
            
            // Map to pixel space [0, 1]
            // offset = (cell_index + random_jitter) / grid_dimension
            offset.x = (gx + jitter.x) / (float)gridW;
            offset.y = (gy + jitter.y) / (float)gridH;
        }
        
        // Map pixel to projection plane coordinates using the jittered offset
        // id.x + offset.x is the continuous pixel coordinate
        float u = ((id.x + offset.x) / width - 0.5) * planeWidth;
        float v = ((id.y + offset.y) / height - 0.5) * planeHeight;
        
        // 2. Generate Camera Ray
        // ----------------------
        
        float3 rayOriginCam;
        float3 rayDirCam;
        
        if (_IsOrthographic == 1)
        {
            // Orthographic: parallel rays, varying origin
            float orthoHalfHeight = _OrthoSize;
            float orthoHalfWidth = orthoHalfHeight * aspect;
            float orthoU = ((id.x + offset.x) / width - 0.5) * 2.0 * orthoHalfWidth;
            float orthoV = ((id.y + offset.y) / height - 0.5) * 2.0 * orthoHalfHeight;
            rayOriginCam = float3(orthoU, orthoV, _CameraDistance);
            rayDirCam = float3(0, 0, -1);
        }
        else
        {
            // Perspective: rays from camera through projection plane
            rayOriginCam = float3(0, 0, _CameraDistance);
            float3 pixelPos = float3(u, v, 0);  // Point on projection plane
            rayDirCam = normalize(pixelPos - rayOriginCam);
        }
        
        // Transform ray from Camera Space to Object Space
        float3 rayOrigin = mul(_CameraToWorld, float4(rayOriginCam, 1.0)).xyz;
        float3 rayDir = normalize(mul((float3x3)_CameraToWorld, rayDirCam));
        
        
        // 3. Trace Ray & Accumulate Color
        // -------------------------------
        
        float3 sampleColor = float3(0, 0, 0);
        float3 attenuation = float3(1, 1, 1);
        Ray ray = CreateRay(rayOrigin, rayDir);
        
        for (int depth = 0; depth < _MaxDepth; depth++)
        {
            HitRecord hit = TraverseBVH(ray);
            
            if (!hit.hit)
            {
                sampleColor += attenuation * _BackgroundColor.rgb;
                break;
            }
            
            // Get material properties
            float3 matColor = float3(1, 1, 1);
            float kAmbient = 0.1;
            float kDiffuse = 0.7;
            float kSpecular = 0.0;
            float kRefraction = 0.0;
            float ior = 1.0;
            
            if (hit.materialIndex >= 0)
            {
                GPUMaterial mat = Materials[hit.materialIndex];
                matColor = mat.color;
                kAmbient = mat.ambient;
                kDiffuse = mat.diffuse;
                kSpecular = mat.specular;
                kRefraction = mat.refraction;
                ior = mat.ior;
            }
            
            float3 localColor = float3(0, 0, 0);
            
            // Ambient
            if (_EnableAmbient == 1) localColor += matColor * kAmbient;
            
            // Lighting
            float3 lightDir = normalize(_LightPosition - hit.position);
            float NdotL = max(0.0f, dot(hit.normal, lightDir));
            
            if (_EnableDiffuse == 1 && NdotL > 0.0)
            {
                Ray shadowRay;
                shadowRay.origin = hit.position + hit.normal * (Epsilon * 100.0);
                shadowRay.direction = lightDir;
                shadowRay.invDirection = 1.0 / lightDir;
                
                HitRecord shadowHit = TraverseBVH(shadowRay);
                
                if (!shadowHit.hit)
                {
                    localColor += matColor * kDiffuse * NdotL;
                    if (_EnableSpecular == 1 && kSpecular > 0.0)
                    {
                        float3 viewDir = normalize(-ray.direction);
                        float3 halfVec = normalize(lightDir + viewDir);
                        float spec = pow(max(dot(hit.normal, halfVec), 0.0), 32.0);
                        localColor += float3(1, 1, 1) * kSpecular * spec;
                    }
                }
            }
            
            sampleColor += attenuation * localColor * _LightIntensity;
            
            // Recursive stepping
            bool shouldReflect = (kSpecular > 0.0);
            bool shouldRefract = (_EnableRefraction == 1 && kRefraction > 0.0);
            
            if (!shouldReflect && !shouldRefract) break;
            
            if (shouldRefract && kRefraction > 0.0)
            {
                float3 I = normalize(ray.direction);
                float3 N = hit.normal;
                float eta = 1.0 / ior;
                if (dot(I, N) > 0) { N = -N; eta = ior; }
                
                float k = 1.0 - eta * eta * (1.0 - dot(-I, N) * dot(-I, N));
                if (k >= 0.0)
                {
                    float3 refractDir = eta * I + (eta * dot(-I, N) - sqrt(k)) * N;
                    ray.origin = hit.position + refractDir * (Epsilon * 100.0);
                    ray.direction = normalize(refractDir);
                    ray.invDirection = 1.0 / ray.direction;
                    attenuation *= matColor * kRefraction;
                }
                else
                {
                    float3 reflectDir = reflect(I, N);
                    ray.origin = hit.position + N * (Epsilon * 100.0);
                    ray.direction = normalize(reflectDir);
                    ray.invDirection = 1.0 / ray.direction;
                    attenuation *= matColor * kSpecular;
                }
            }
            else if (shouldReflect && kSpecular > 0.0)
            {
                float3 reflectDir = reflect(normalize(ray.direction), hit.normal);
                ray.origin = hit.position + hit.normal * (Epsilon * 100.0);
                ray.direction = normalize(reflectDir);
                ray.invDirection = 1.0 / ray.direction;
                attenuation *= matColor * kSpecular;
            }
        }
        
        pixelColorAccum += sampleColor;
    }
    
    // Average samples
    float3 finalColor = pixelColorAccum / (float)sampleCount;
    
    // ==========================================================================
    // DEBUG MODES (Overwrites final color if enabled)
    // ==========================================================================
    
    if (_DebugMode != 0)
    {
        // Re-trace center ray for debug
        float3 rayOrigin, rayDir; // Need to recalc center ray...
        // ... (simplified debug logic would be better here, skipping for now as AA complicates it)
        // Ideally we just output the debug color from the first sample logic?
        // But debug mode usually disables AA or we just skip AA.
        // For now, if debug is on, let's just use the first sample result or similar.
        // Or re-implement debug logic simply.
        // Given complexity, I will just leave Debug Mode logic at the end, but it needs data.
        // I will assume debug mode is 0 for AA task.
        // To be safe, let's wrap AA loop in "if Debug == 0".
    }
    
    if (_DebugMode == 1)  // Depth visualization
    {
        // Simple Center Ray
        float u = ((id.x + 0.5) / width - 0.5) * planeWidth;
        float v = ((id.y + 0.5) / height - 0.5) * planeHeight;
        float3 ro = float3(0,0, _CameraDistance);
        float3 rd = normalize(float3(u,v,0) - ro);
        float3 wro = mul(_CameraToWorld, float4(ro, 1.0)).xyz;
        float3 wrd = normalize(mul((float3x3)_CameraToWorld, rd));
        HitRecord hit = TraverseBVH(CreateRay(wro, wrd));
        if (hit.hit) finalColor = float3(hit.t / 100.0, hit.t / 100.0, hit.t / 100.0);
        else finalColor = float3(1, 0, 0);
    }
    else if (_DebugMode == 2)  // Normal
    {
        float u = ((id.x + 0.5) / width - 0.5) * planeWidth;
        float v = ((id.y + 0.5) / height - 0.5) * planeHeight;
        float3 ro = float3(0,0, _CameraDistance);
        float3 rd = normalize(float3(u,v,0) - ro);
        float3 wro = mul(_CameraToWorld, float4(ro, 1.0)).xyz;
        float3 wrd = normalize(mul((float3x3)_CameraToWorld, rd));
        HitRecord hit = TraverseBVH(CreateRay(wro, wrd));
        if (hit.hit) finalColor = hit.normal * 0.5 + 0.5;
        else finalColor = float3(0, 0, 1);
    }
    else if (_DebugMode == 3)  // Hit
    {
        float u = ((id.x + 0.5) / width - 0.5) * planeWidth;
        float v = ((id.y + 0.5) / height - 0.5) * planeHeight;
        float3 ro = float3(0,0, _CameraDistance);
        float3 rd = normalize(float3(u,v,0) - ro);
        float3 wro = mul(_CameraToWorld, float4(ro, 1.0)).xyz;
        float3 wrd = normalize(mul((float3x3)_CameraToWorld, rd));
        HitRecord hit = TraverseBVH(CreateRay(wro, wrd));
        finalColor = hit.hit ? float3(0, 1, 0) : float3(0.2, 0.2, 0.2);
    }
    
    Result[id.xy] = float4(finalColor, 1.0f);
}
