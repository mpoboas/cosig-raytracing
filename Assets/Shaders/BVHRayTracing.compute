#pragma kernel CSMain

// --- Data Structures ---

struct Ray
{
    float3 origin;
    float3 direction;
    float3 invDirection;
};

struct HitRecord
{
    bool hit;
    float t;
    float3 position;
    float3 normal;
    int materialIndex;
};

struct GPUBVHNode
{
    float3 min;
    int leftOrFirst; // Internal: Left Child Index | Leaf: First Triangle Index
    float3 max;
    int count;       // Internal: 0 | Leaf: Triangle Count
};

struct GPUTriangle
{
    float3 v0;
    float3 v1;
    float3 v2;
    float3 n0; // Vertex normal at v0
    float3 n1; // Vertex normal at v1
    float3 n2; // Vertex normal at v2
    float3 center;
    int materialIndex;
};

struct GPUMaterial
{
    float3 color;
    float ambient;
    float diffuse;
    float specular;
    float refraction;
    float ior;
};

// --- Buffers & Uniforms ---

RWTexture2D<float4> Result;
StructuredBuffer<GPUBVHNode> BVHNodes;
StructuredBuffer<GPUTriangle> Triangles;
StructuredBuffer<GPUMaterial> Materials;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float _CameraDistance;
float _CameraFOV;
float3 _LightDirection; // Simple directional light for now
float _Time;
int _MaxDepth;
int _DebugMode; // 0=normal, 1=depth, 2=normals, 3=hit visualization
int _EnableAmbient;
int _EnableDiffuse;
int _EnableSpecular;
int _EnableRefraction;
float _LightIntensity;
float3 _LightPosition;
float4 _BackgroundColor;
int _IsOrthographic;
float _OrthoSize;

static const float Infinity = 3.402823466e+38;
static const float Epsilon = 1e-4;

// --- Helper Functions ---

Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    ray.invDirection = 1.0f / direction;
    return ray;
}

// MÃ¶ller-Trumbore Intersection
void IntersectTriangle(Ray ray, GPUTriangle tri, inout HitRecord bestHit)
{
    float3 v0v1 = tri.v1 - tri.v0;
    float3 v0v2 = tri.v2 - tri.v0;
    float3 pvec = cross(ray.direction, v0v2);
    float det = dot(v0v1, pvec);

    // Culling
    // if (det < Epsilon) return; 

    if (abs(det) < Epsilon) return; // No backface culling for now

    float invDet = 1.0f / det;
    float3 tvec = ray.origin - tri.v0;
    float u = dot(tvec, pvec) * invDet;

    if (u < 0.0f || u > 1.0f) return;

    float3 qvec = cross(tvec, v0v1);
    float v = dot(ray.direction, qvec) * invDet;

    if (v < 0.0f || u + v > 1.0f) return;

    float t = dot(v0v2, qvec) * invDet;

    if (t > Epsilon && t < bestHit.t)
    {
        bestHit.hit = true;
        bestHit.t = t;
        bestHit.position = ray.origin + t * ray.direction;
        // Interpolate vertex normals using barycentric coordinates (w = 1-u-v, u, v)
        float w = 1.0 - u - v;
        bestHit.normal = normalize(w * tri.n0 + u * tri.n1 + v * tri.n2);
        bestHit.materialIndex = tri.materialIndex;
    }
}

// Slab Method Intersection
float IntersectAABB(Ray ray, float3 boxMin, float3 boxMax)
{
    float3 t0 = (boxMin - ray.origin) * ray.invDirection;
    float3 t1 = (boxMax - ray.origin) * ray.invDirection;
    
    float3 tmin = min(t0, t1);
    float3 tmax = max(t0, t1);
    
    float dstA = max(max(tmin.x, tmin.y), tmin.z);
    float dstB = min(min(tmax.x, tmax.y), tmax.z);
    
    if (dstA > dstB || dstB < 0) return Infinity;
    
    return dstA; // Returns distance to entry point
}

// --- Traversal ---

HitRecord TraverseBVH(Ray ray)
{
    HitRecord hit;
    hit.hit = false;
    hit.t = Infinity;
    hit.normal = float3(0, 1, 0);
    hit.position = float3(0, 0, 0);
    hit.materialIndex = -1;

    // Manual Stack
    int stack[32];
    int stackPtr = 0;
    stack[stackPtr++] = 0; // Push Root

    while (stackPtr > 0)
    {
        int nodeIdx = stack[--stackPtr]; // Pop
        GPUBVHNode node = BVHNodes[nodeIdx];

        // Ensure we intersect the bounding box before checking contents
        // Optimization: if distance to box is > current bestHit.t, skip
        float dst = IntersectAABB(ray, node.min, node.max);
        if (dst >= hit.t) continue;

        if (node.count > 0) // Leaf
        {
            for (int i = 0; i < node.count; i++)
            {
                GPUTriangle tri = Triangles[node.leftOrFirst + i];
                IntersectTriangle(ray, tri, hit);
            }
        }
        else // Internal
        {
            // Push children
            // Optimization: Push the farther child first so the closer one is popped first
            // Is calculating order worth it? For now, just push Right (First+1) then Left (First)
            int leftIdx = node.leftOrFirst;
            int rightIdx = leftIdx + 1;
            
            // Check bounding boxes to order push
            // But we already check Intersect in loop start. 
            // Simple push:
            stack[stackPtr++] = rightIdx;
            stack[stackPtr++] = leftIdx;
        }
    }
    
    return hit;
}

// --- Shading ---

float3 Shade(Ray ray, HitRecord hit)
{
    if (!hit.hit) return float3(0.05, 0.05, 0.05); // Background

    // Get material
    float3 matColor = float3(1, 1, 1);
    float kAmbient = 0.1;
    float kDiffuse = 0.7;
    float kSpecular = 0.0;
    
    if (hit.materialIndex >= 0)
    {
        GPUMaterial mat = Materials[hit.materialIndex];
        matColor = mat.color;
        kAmbient = mat.ambient;
        kDiffuse = mat.diffuse;
        kSpecular = mat.specular;
    }

    float3 result = float3(0, 0, 0);
    
    // Ambient
    if (_EnableAmbient == 1)
    {
        result += matColor * kAmbient;
    }
    
    // Diffuse + Specular
    if (_EnableDiffuse == 1 || _EnableSpecular == 1)
    {
        float3 lightDir = normalize(float3(1, 1, -1));
        float NdotL = max(0.0f, dot(hit.normal, lightDir));
        
        if (_EnableDiffuse == 1)
        {
            result += matColor * kDiffuse * NdotL;
        }
        
        if (_EnableSpecular == 1 && kSpecular > 0.0)
        {
            // Blinn-Phong
            float3 viewDir = normalize(-ray.direction);
            float3 halfVec = normalize(lightDir + viewDir);
            float spec = pow(max(dot(hit.normal, halfVec), 0.0), 32.0);
            result += float3(1,1,1) * kSpecular * spec;
        }
    }
    
    return result * _LightIntensity;
}


// --- Main Kernel ---

[numthreads(8, 8, 1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);
    
    if (id.x >= width || id.y >= height) return;

    // Ray generation matching CPU implementation EXACTLY
    // Camera at (0, 0, distance), looking down -Z
    // CPU code: origin=(0,0,distance), direction=(u,v,-distance).normalized
    
    // Calculate projection plane size from FOV
    float aspect = (float)width / (float)height;
    float halfHeight = _CameraDistance * tan(radians(_CameraFOV) * 0.5);
    float planeHeight = 2.0 * halfHeight;
    float planeWidth = planeHeight * aspect;
    
    // Pixel to projection plane coordinates
    float u = ((id.x + 0.5) / width - 0.5) * planeWidth;
    float v = ((id.y + 0.5) / height - 0.5) * planeHeight;
    
    // Primary ray in camera space
    float3 rayOrigin;
    float3 rayDir;
    
    if (_IsOrthographic == 1)
    {
        // Orthographic: parallel rays, origin varies, direction is constant
        float orthoHalfHeight = _OrthoSize;
        float orthoHalfWidth = orthoHalfHeight * aspect;
        float orthoU = ((id.x + 0.5) / width - 0.5) * 2.0 * orthoHalfWidth;
        float orthoV = ((id.y + 0.5) / height - 0.5) * 2.0 * orthoHalfHeight;
        rayOrigin = float3(orthoU, orthoV, _CameraDistance);
        rayDir = float3(0, 0, -1); // All rays point straight down -Z
    }
    else
    {
        // Perspective: origin at camera, direction varies
        rayOrigin = float3(0, 0, _CameraDistance);
        rayDir = normalize(float3(u, v, -_CameraDistance));
    }
    
    // Iterative ray tracing with reflection/refraction
    float3 finalColor = float3(0, 0, 0);
    float3 attenuation = float3(1, 1, 1); // Accumulated color filter
    
    Ray ray = CreateRay(rayOrigin, rayDir);
    
    for (int depth = 0; depth < _MaxDepth; depth++)
    {
        HitRecord hit = TraverseBVH(ray);
        
        if (!hit.hit)
        {
            // Background from UI
            finalColor += attenuation * _BackgroundColor.rgb;
            break;
        }
        
        // Get material properties
        float3 matColor = float3(1, 1, 1);
        float kAmbient = 0.1;
        float kDiffuse = 0.7;
        float kSpecular = 0.0;
        float kRefraction = 0.0;
        float ior = 1.0;
        
        if (hit.materialIndex >= 0)
        {
            GPUMaterial mat = Materials[hit.materialIndex];
            matColor = mat.color;
            kAmbient = mat.ambient;
            kDiffuse = mat.diffuse;
            kSpecular = mat.specular;
            kRefraction = mat.refraction;
            ior = mat.ior;
        }
        
        // Calculate local shading (ambient + diffuse + specular highlights)
        float3 localColor = float3(0, 0, 0);
        
        if (_EnableAmbient == 1)
        {
            localColor += matColor * kAmbient;
        }
        
        // Calculate light direction from scene light position
        float3 lightDir = normalize(_LightPosition - hit.position);
        float NdotL = max(0.0f, dot(hit.normal, lightDir));
        
        if (_EnableDiffuse == 1 && NdotL > 0.0)
        {
            // Cast shadow ray with larger bias to prevent self-shadowing
            Ray shadowRay;
            shadowRay.origin = hit.position + hit.normal * (Epsilon * 100.0);
            shadowRay.direction = lightDir;
            shadowRay.invDirection = 1.0 / lightDir;
            
            HitRecord shadowHit = TraverseBVH(shadowRay);
            
            // Only add diffuse if not in shadow
            if (!shadowHit.hit)
            {
                localColor += matColor * kDiffuse * NdotL;
                
                // Add specular highlights (Blinn-Phong) - controlled by toggle
                if (_EnableSpecular == 1 && kSpecular > 0.0)
                {
                    float3 viewDir = normalize(-ray.direction);
                    float3 halfVec = normalize(lightDir + viewDir);
                    float spec = pow(max(dot(hit.normal, halfVec), 0.0), 32.0);
                    localColor += float3(1, 1, 1) * kSpecular * spec;
                }
            }
        }
        
        // Add local contribution
        finalColor += attenuation * localColor * _LightIntensity;
        
        // Determine next ray (reflection or refraction) - NOT controlled by toggles
        bool shouldReflect = (kSpecular > 0.0); // Always reflect if material allows
        bool shouldRefract = (_EnableRefraction == 1 && kRefraction > 0.0); // Refraction still needs toggle
        
        if (!shouldReflect && !shouldRefract)
        {
            // No recursive rays needed
            break;
        }
        
        if (shouldRefract && kRefraction > 0.0)
        {
            // Refraction
            float3 I = normalize(ray.direction);
            float3 N = hit.normal;
            float eta = 1.0 / ior; // Assuming entering from air (ior=1)
            
            // Check if we're exiting
            if (dot(I, N) > 0)
            {
                N = -N;
                eta = ior; // Exiting to air
            }
            
            float k = 1.0 - eta * eta * (1.0 - dot(-I, N) * dot(-I, N));
            
            if (k >= 0.0)
            {
                // Refract
                float3 refractDir = eta * I + (eta * dot(-I, N) - sqrt(k)) * N;
                ray.origin = hit.position + refractDir * (Epsilon * 100.0);
                ray.direction = normalize(refractDir);
                ray.invDirection = 1.0 / ray.direction;
                attenuation *= matColor * kRefraction;
            }
            else
            {
                // Total internal reflection
                float3 reflectDir = reflect(I, N);
                ray.origin = hit.position + N * (Epsilon * 100.0);
                ray.direction = normalize(reflectDir);
                ray.invDirection = 1.0 / ray.direction;
                attenuation *= matColor * kSpecular;
            }
        }
        else if (shouldReflect && kSpecular > 0.0)
        {
            // Reflection
            float3 reflectDir = reflect(normalize(ray.direction), hit.normal);
            ray.origin = hit.position + hit.normal * (Epsilon * 100.0);
            ray.direction = normalize(reflectDir);
            ray.invDirection = 1.0 / ray.direction;
            attenuation *= matColor * kSpecular;
        }
    }
    
    // Debug modes
    if (_DebugMode == 1) // Depth visualization
    {
        HitRecord hit = TraverseBVH(CreateRay(rayOrigin, rayDir));
        if (hit.hit)
            finalColor = float3(hit.t / 100.0, hit.t / 100.0, hit.t / 100.0);
        else
            finalColor = float3(1, 0, 0);
    }
    else if (_DebugMode == 2) // Normals
    {
        HitRecord hit = TraverseBVH(CreateRay(rayOrigin, rayDir));
        if (hit.hit)
            finalColor = hit.normal * 0.5 + 0.5;
        else
            finalColor = float3(0, 0, 1);
    }
    else if (_DebugMode == 3) // Hit visualization
    {
        HitRecord hit = TraverseBVH(CreateRay(rayOrigin, rayDir));
        finalColor = hit.hit ? float3(0, 1, 0) : float3(0.2, 0.2, 0.2);
    }
    
    Result[id.xy] = float4(finalColor, 1.0f);
}
